# 19-Interview

---

## JavaScript知识点

---

### 闭包

谈到闭包少不了关于作用域的讲解。要想理解作用域的实现机制，我们需要结合 JS 的编译原理一起来看。

``` 
var name = '19-Qingfeng'
```

这段代码在JS中其实做了两件事。

* var name （编译时处理）

* name = 19-Qingfeng （运行时处理）

> 事实上，JS 也是有编译阶段的，它和传统语言的区别在于，JS 不会早早地把编译工作做完，而是一边编译一边执行。简单来说，所有的 JS 代码片段在执行之前都会被编译，只是这个编译的过程非常短暂（可能就只有几微妙、或者更短的时间），紧接着这段代码就会被执行。

* 编译阶段： 这时登场的是一个叫 编译器 的家伙。编译器会找遍当前作用域，看看是不是已经有一个叫 name 的家伙了。如果有，那么就忽略 var name 这个声明，继续编译下去；如果没有，则在当前作用域里新增一个 name。然后，编译器会为引擎生成运行时所需要的代码，程序就进入了执行阶段

* 执行阶段： 这时登场的就是大家常常听到的 JS 引擎 了。JS 引擎在执行代码的时候，仍然会找遍当前作用域，看看是不是有一个叫 name 的家伙。如果能找到，那么万事大吉，我来给你赋值。如果找不到，它也不会灰心，它会从当前作用域里 “探出头去”，看看 “外面” 有没有，或者 “外面的外面” 有没有。如果最终仍然找不到 name 变量，引擎就会抛出一个异常。

#### 作用域套作用域，就有了作用域链

> 作用域本质上就是程序存储和访问变量的规则。

目前JS语言中已经有了三种作用域链：

1. 全局作用域。 

2. 函数作用域。

3. 块级作用域:ES6开始的let和const声明。

> 看看下面这个例子

``` 
function addABC(){
  var a = 1,b = 2;
  
  function add(){
    return a+b+c;
  }
  return add;
}

var c = 3

var globalAdd = addABC()

console.log(globalAdd()) // 6

```

上面例子的嵌套规则和作用域用图来说:

![bibao.jpg](https://i.loli.net/2020/09/03/tO84CzAa1y2GKwR.png)

他的作用域链是这样的

![bibao2.jpg](https://i.loli.net/2020/09/03/WSZOKTuBeJIYUda.png)

其中 add 这个函数，它嵌套在函数 addABC 的内部，想要查找 a、b、c 三个变量，它得去上层的 addABC 作用域里找，对吧？

#### 引出闭包的概念:

**像 a、b、c 这样在函数中被使用，但它既不是函数参数、也不是函数的局部变量，而是一个不属于当前作用域的变量，此时它相对于当前作用域来说，就是一个自由变量。而像 add 这样引用了自由变量的函数，就叫闭包。**

#### 顺道说说 LHS、 RHS

LHS、RHS，是引擎在执行代码的时候，查询变量的两种方式。其中的 L、R，分别意味着 Left、Right。这个“左”和“右”，是相对于赋值操作来说的。当变量出现在赋值操作的左侧时，执行的就是 LHS 操作，右侧则执行 RHS 操作：

``` 
name = '19-Qingfeng';
```

在这个例子里，name 变量出现在赋值操作的左侧，它就属于 LHS。**LHS 意味着 变量赋值或写入内存，**

它强调的是一个写入的动作，所以 LHS 查询查的是这个变量的“家”（对应的内存空间）在哪。

``` 
var myName = name
console.log(name)
```

在这个例子里，第一行有赋值操作，但是 name 在操作的右侧，所以是 RHS；第二行没有赋值操作，name 就可以理解为没有出现在赋值操作的左侧，这种情况下我们也认为 name 的查询是 RHS。**RHS意味着变量查找或从内存中读取，它强调的是读这个动作，查询的是变量的内容。**
